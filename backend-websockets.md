# Архитектура WebSocket на Бэкенде (Spring Boot)

Этот документ описывает, как реализована система реального времени с использованием WebSocket и STOMP в нашем проекте.

## 1. Основные принципы

В основе архитектуры лежит протокол **STOMP** (Simple Text Oriented Messaging Protocol), работающий поверх WebSocket. Это позволяет нам общаться не просто потоками данных, а полноценными сообщениями с заголовками и телом, по принципу "публикация-подписка" (pub-sub).

- **Клиенты (фронтенд)** подписываются на "темы" или "топики" (например, `/topic/rooms`).
- **Сервер (бэкенд)** отправляет сообщения в эти топики.
- **Брокер сообщений** (в нашем случае, встроенный в Spring) доставляет эти сообщения всем подписчикам.

## 2. Ключевые адреса (Endpoints)

### 2.1. Адреса для Клиента (Куда обращаться)

- **Подключение:** `http://localhost:8080/ws` — это главный эндпоинт для установки WebSocket-соединения.
- **Подписка на список комнат:** `/topic/rooms` — сюда сервер присылает обновленный список комнат.
- **Подписка на игроков в комнате:** `/topic/room/{roomId}/players` — сюда сервер присылает список игроков для конкретной комнаты.
- **Подписка на состояние игры:** `/topic/room/{roomId}/state` — сюда сервер присылает актуальное состояние игры (здоровье игроков и т.д.).

### 2.2. Адреса для Сервера (Куда отправлять действия)

Все действия от клиента отправляются с префиксом `/app`.

- **Создать комнату:** `/app/rooms/create` (в теле — название комнаты).
- **Присоединиться к комнате:** `/app/rooms/join` (в теле — JSON с `roomId` и `player`).
- **Покинуть комнату:** `/app/rooms/leave` (в теле — JSON с `roomId` и `player`).
- **Встать в очередь матчмейкинга:** `/app/matchmaking/join` (в теле — JSON с `player`).
- **Совершить игровое действие:** `/app/room/{roomId}/action` (в теле — JSON с `targetId` и `damage`).

## 3. Конфигурация

### `WebSocketConfig.java`
Это главный конфигурационный файл.
- `registry.addEndpoint("/ws").setAllowedOriginPatterns("*").withSockJS();` — регистрирует основной эндпоинт `/ws` и разрешает подключения с любых источников (важно для разработки). `withSockJS()` обеспечивает фолбэк для старых браузеров.
- `config.enableSimpleBroker("/topic");` — включает простого брокера сообщений, который будет обрабатывать все топики, начинающиеся с `/topic`.
- `config.setApplicationDestinationPrefixes("/app");` — устанавливает префикс `/app` для всех сообщений, которые должны быть обработаны нашими `@MessageMapping` контроллерами.

### `AppSecurityConfig.java` & `WebConfig.java`
Эти файлы настраивают безопасность и CORS. Мы разрешили публичный доступ к `/ws/**` и всем остальным эндпоинтам (`"/**"`) для простоты разработки, а также настроили CORS, чтобы браузер не блокировал запросы с `localhost:3000` на `localhost:8080`.

## 4. Поток данных (Data Flow)

### 4.1. Получение списка комнат

1.  **Клиент** подключается и подписывается на `/topic/rooms`.
2.  **Сервер**, благодаря аннотации `@SubscribeMapping("/rooms")` в `RoomController`, видит эту подписку и **немедленно** отправляет текущий список комнат этому конкретному клиенту. Это решает "состояние гонки".
3.  Когда кто-то создает или покидает комнату, `RoomController` вызывает `broadcastRooms()`, который отправляет обновленный список **всем подписчикам** `/topic/rooms`.

### 4.2. Игровой процесс

1.  Два игрока заходят в комнату. Второй игрок заходит, и `RoomController` видит, что комната заполнена (`size == 2`).
2.  Сервер устанавливает `room.setFull(true)`, чтобы скрыть ее из лобби.
3.  Сервер инициализирует `GameState` (устанавливает игроков) и отправляет его в `/topic/room/{roomId}/state`.
4.  Оба игрока, подписанные на этот топик, получают `GameState` и отображают игровой интерфейс (здоровье, кнопки).
5.  **Игрок 1** нажимает "Атаковать".
6.  **Фронтенд** отправляет сообщение на `/app/room/{roomId}/action` с данными об атаке.
7.  `GameController` на бэкенде получает это сообщение.
8.  Он вызывает `gameState.apply(action)`, изменяя здоровье **Игрока 2** внутри серверного объекта `GameState`.
9.  `GameController` отправляет **обновленный** `GameState` всем подписчикам топика `/topic/room/{roomId}/state`.
10. **Оба клиента** получают новый `GameState` и перерисовывают интерфейс, отображая новое значение здоровья.

Этот цикл "Действие -> Сервер -> Обновление состояния -> Рассылка всем" является ядром синхронизации в реальном времени.